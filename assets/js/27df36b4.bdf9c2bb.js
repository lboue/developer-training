"use strict";(self.webpackChunkgolioth_developer_training=self.webpackChunkgolioth_developer_training||[]).push([[217],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=r,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9712:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:1,description:"Set up and use a sensor that has a driver built-in to Zephyr"},o="Using Zephyr Sensor Drivers",s={unversionedId:"sensor-exercises/sensor-dps310",id:"sensor-exercises/sensor-dps310",title:"Using Zephyr Sensor Drivers",description:"Set up and use a sensor that has a driver built-in to Zephyr",source:"@site/docs/sensor-exercises/sensor-dps310.md",sourceDirName:"sensor-exercises",slug:"/sensor-exercises/sensor-dps310",permalink:"/docs/sensor-exercises/sensor-dps310",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Set up and use a sensor that has a driver built-in to Zephyr"},sidebar:"tutorialSidebar",previous:{title:"Sensor Exercises",permalink:"/docs/category/sensor-exercises"},next:{title:"After Training",permalink:"/docs/category/after-training"}},l={},p=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Desired outcome(s)",id:"desired-outcomes",level:3},{value:"Time Estimate",id:"time-estimate",level:3},{value:"Background information",id:"background-information",level:2},{value:"Connecting the Sensor",id:"connecting-the-sensor",level:3},{value:"Devicetree and Pin Control",id:"devicetree-and-pin-control",level:3},{value:"Using Kconfig to build in the necessary libraries",id:"using-kconfig-to-build-in-the-necessary-libraries",level:3},{value:"Getting the sensor node from Devicetree and using it",id:"getting-the-sensor-node-from-devicetree-and-using-it",level:3},{value:"Workflow",id:"workflow",level:2},{value:"Exercise: Run DSP310 Code Sample",id:"exercise-run-dsp310-code-sample",level:3},{value:"Exercise: Stream DPS310 Data to Golioth LightDB",id:"exercise-stream-dps310-data-to-golioth-lightdb",level:3}],d={toc:p};function c(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-zephyr-sensor-drivers"},"Using Zephyr Sensor Drivers"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"MagTag connected to the DPS310 pressure sensor",src:n(3615).Z,width:"1000",height:"604"})),(0,r.kt)("p",null,"For this exercise you will be building an app that reads temperature and\nhumidity data from an ",(0,r.kt)("a",{parentName:"p",href:"https://www.infineon.com/cms/en/product/sensor/pressure-sensors/pressure-sensors-for-iot/dps310/"},"Infineon\nDPS310"),"\npressure and temperature sensor. The concepts are similar for any supported\nsensor, so if you don't have this part you can still follow along, assuming that there is a driver for the sensor you do have on hand. The best place to look for driver support is in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zephyrproject-rtos/zephyr/tree/main/drivers/sensor"},"driver/sensor")," folder of the Zephyr toolchain."),(0,r.kt)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,r.kt)("p",null,"When you want to implement a new sensor on a piece of hardware, you need to write firmware for it. If you choose a sensor that already has a device driver in Zephyr, you can cut down on the overall amount of code you write, but you will need to understand how to hook up the sensor firmware to utilize the driver (non-intuitive, unfortunately)."),(0,r.kt)("h3",{id:"desired-outcomes"},"Desired outcome(s)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understand where to find Zephyr sensor driver code"),(0,r.kt)("li",{parentName:"ul"},"Understand how to hook up the sensor driver code to your application"),(0,r.kt)("li",{parentName:"ul"},"Understand how to utilize the data coming back from the sensor driver code"),(0,r.kt)("li",{parentName:"ul"},"Understand how to pipe that data to other parts of your application, like sending it to the Golioth Cloud.")),(0,r.kt)("h3",{id:"time-estimate"},"Time Estimate"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"20 minutes")),(0,r.kt)("h2",{id:"background-information"},"Background information"),(0,r.kt)("h3",{id:"connecting-the-sensor"},"Connecting the Sensor"),(0,r.kt)("p",null,"This sensor includes an i2c interface which is easy to connect to the MagTag\nusing a QWiic cable."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"MagTag i2c pinout",src:n(3657).Z,width:"600",height:"277"})),(0,r.kt)("p",null,"After referencing ",(0,r.kt)("a",{parentName:"p",href:"https://learn.adafruit.com/assets/96946"},"the MagTag schematic"),"\nwe see the SDA and SCL pins are on IO33 and IO34. With this information in hand,\nwe can create an overlay file that defines the DPS310 in the Devicetree."),(0,r.kt)("h3",{id:"devicetree-and-pin-control"},"Devicetree and Pin Control"),(0,r.kt)("p",null,"We need to use an i2c peripheral. An entry already exists for ",(0,r.kt)("inlineCode",{parentName:"p"},"i2c1")," in the\nesp32s2_saola dts file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="excerpt from ~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola.dts"',title:'"excerpt',from:!0,'~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola.dts"':!0},'&i2c1 {\n    clock-frequency = <I2C_BITRATE_STANDARD>;\n    pinctrl-0 = <&i2c1_default>;\n    pinctrl-names = "default";\n};\n')),(0,r.kt)("p",null,"Two important things to note from the node above: there is no status listed which\nmeans the peripheral is not enabled, and the pinctrl-0 entry tells us to look\nfor the ",(0,r.kt)("inlineCode",{parentName:"p"},"i2c1_default")," node in the pinctrl.dtsi file to see how the pins are\nmapped and configured:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="excerpt from ~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola-pinctrl.dtsi"',title:'"excerpt',from:!0,'~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola-pinctrl.dtsi"':!0},"&pinctrl {\n    i2c1_default: i2c1_default {\n        group1 {\n            pinmux = <I2C1_SDA_GPIO3>,\n                 <I2C1_SCL_GPIO4>;\n            bias-pull-up;\n            drive-open-drain;\n            output-high;\n        };\n    };\n};\n")),(0,r.kt)("p",null,"This shows that by default the saola board maps i2c1 to GPIO3 and GPIO4. We now\nhave all the information we need to change this pin mapping and enable the\nperipheral. We will also tell Zephyr that we have connected a sensor by adding\nit as a subnode of i2c1."),(0,r.kt)("p",null,"Create your ",(0,r.kt)("inlineCode",{parentName:"p"},"boards/esp32s2_saola.overlay")," file with the following contents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="esp32s2_saola.overlay"',title:'"esp32s2_saola.overlay"'},'&i2c1 {\n    pinctrl-0 = <&i2c1_default>;\n    pinctrl-names = "default";\n    status = "okay";\n\n    pressure1: DPS310@77 {\n        status = "okay";\n        compatible = "infineon,dps310";\n        reg = <0x77>;\n    };\n};\n\n&pinctrl {\n    i2c1_default: i2c1_default {\n        group1 {\n            pinmux = <I2C1_SDA_GPIO33>,\n                 <I2C1_SCL_GPIO34>;\n        };\n    };\n};\n')),(0,r.kt)("p",null,"Let's walk through everything that's going on in our new overlay file:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Included the pinctrl-0 and pinctrl-names assignments so it's very clear\nwith Pin Control state is being used. (Technically, these would have been\ninherited from the board definitions and don't need to be here.)"),(0,r.kt)("li",{parentName:"ul"},'Set the status of i2c1 to "okay" to enable the node'),(0,r.kt)("li",{parentName:"ul"},"Add a child node that defines the DPS310:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Declare a ",(0,r.kt)("inlineCode",{parentName:"li"},"pressure1")," node label",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"DPS310")," path is appended with the address of the i2c device: ",(0,r.kt)("inlineCode",{parentName:"li"},"@77")))),(0,r.kt)("li",{parentName:"ul"},'Sets the status of the DPS31 to "okay" to enable the subnode'),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"compatible")," property is set using the device tree bindings. You can\nlook these up in ",(0,r.kt)("a",{parentName:"li",href:"https://docs.zephyrproject.org/latest/build/dts/api/bindings.html#devicetree-binding-index"},"the binding\nindex"),"."),(0,r.kt)("li",{parentName:"ul"},"Specify the device address as a ",(0,r.kt)("inlineCode",{parentName:"li"},"reg")," value"))),(0,r.kt)("li",{parentName:"ul"},"Add a pinctrl node to reassign the i2c1 pins",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Map the sda and scl pins to IO33 and IO34 to match the MagTag schematic"),(0,r.kt)("li",{parentName:"ul"},"Pin configuration will be inherited from the saola board definition in\nZephyr.")))),(0,r.kt)("p",null,"As with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/basic-io-exercises/mapping-gpio"},"LED")," and\n",(0,r.kt)("a",{parentName:"p",href:"/docs/basic-io-exercises/button-input"},"Button")," examples, the node and subnode\nDevicetree entries are all that is needed to set up the hardware abstraction for\nthe i2c peripheral, and the DPS310 part itself. But remapping peripheral pins\nrequires the use of a pinctrl node too."),(0,r.kt)("h3",{id:"using-kconfig-to-build-in-the-necessary-libraries"},"Using Kconfig to build in the necessary libraries"),(0,r.kt)("p",null,"Up to this point we've spent quite a bit of time on Devicetree but have not even\ntouched on the other half of Zephyr configuration. Kconfig is a series of files\nthat tell the build system what libraries to include in the build (along with\nall of the necessary variables, settings, and dependencies that go along with\nthem). In this example, we'll work with the ",(0,r.kt)("inlineCode",{parentName:"p"},"prj.conf")," file, which is\nproject-level configuration."),(0,r.kt)("p",null,"To use an i2c sensor, there are three main libraries you need to include in the\nbuild by adding the following lines to the ",(0,r.kt)("inlineCode",{parentName:"p"},"prj.conf"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"CONFIG_I2C=y\nCONFIG_SENSOR=y\nCONFIG_DPS310=y\n")),(0,r.kt)("h3",{id:"getting-the-sensor-node-from-devicetree-and-using-it"},"Getting the sensor node from Devicetree and using it"),(0,r.kt)("p",null,"It is surprisingly easy to pull in the sensor node and use it. This is thanks to\nthe uniformed API that Zephyr has implemented for sensors."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"const struct device *dev = DEVICE_DT_GET(DT_NODELABEL(pressure1));\nsensor_sample_fetch(dev);\n")),(0,r.kt)("p",null,"That is all you need to do to fetch a sensor value. There is some additional\nhousekeeping that helps you associate the values with the data type, and to\ndisplay it as a human readable value. But after running the two lines above, you\nwill have read data from the sensor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:"main.c","main.c":!0},'#include <zephyr.h>\n#include <device.h>\n#include <drivers/sensor.h>\n#include <stdlib.h>\n\nvoid main(void)\n{\n    printk("Hello DPS310\\n");\n    const struct device *dev = DEVICE_DT_GET(DT_NODELABEL(pressure1));\n\n    if (dev == NULL) {\n        printk("Could not get DPS310 device\\n");\n        return;\n    }\n\n    printk("dev %p name %s\\n", dev, dev->name);\n\n    while (1) {\n        struct sensor_value temp, press;\n\n        sensor_sample_fetch(dev);\n        sensor_channel_get(dev, SENSOR_CHAN_AMBIENT_TEMP, &temp);\n        sensor_channel_get(dev, SENSOR_CHAN_PRESS, &press);\n\n        printk("temp: %d.%06d; press: %d.%06d\\n",\n              temp.val1, abs(temp.val2), press.val1, press.val2);\n\n        k_sleep(K_MSEC(1000));\n    }\n}\n')),(0,r.kt)("h2",{id:"workflow"},"Workflow"),(0,r.kt)("h3",{id:"exercise-run-dsp310-code-sample"},"Exercise: Run DSP310 Code Sample"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zephyrproject-rtos/zephyr/tree/main/samples/sensor/dps310"},"code sample for the\nDPS310"),"\nis available in Zephyr. It is nearly identical to the code outlined above. As an\nexercise:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Make a copy of the code sample into your ",(0,r.kt)("inlineCode",{parentName:"p"},"app")," directory:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"cd ~/magtag-training/app\ncp -r ../deps/zephyr/samples/sensor/dps310\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Study the ",(0,r.kt)("inlineCode",{parentName:"p"},"app.overlay")," file from the sample and compare it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"*dev"),"\nassignment in ",(0,r.kt)("inlineCode",{parentName:"p"},"main.c"),"."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"* Notice the different approach that was taken by the sample writers from\n  what is outlined above. There is more than one way to get information from\n  the Devicetree.\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"app.overlay")," file and add a ",(0,r.kt)("inlineCode",{parentName:"p"},"boards")," directory. Place your\n",(0,r.kt)("inlineCode",{parentName:"p"},"esp32s2_saola.overlay")," file inside with the Devicetree entries as shown above.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Alter ",(0,r.kt)("inlineCode",{parentName:"p"},"main.c")," to work with the way your overlay file defines the sensor.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Build, flash, and run the sample. Verify it is printing pressure and\ntemperature data to the serial console."))),(0,r.kt)("h3",{id:"exercise-stream-dps310-data-to-golioth-lightdb"},"Exercise: Stream DPS310 Data to Golioth LightDB"),(0,r.kt)("p",null,"Make this example into an IoT device by sending the senor readings to Golioth's\nLightDB Stream. To be successful at this, you will need to combine a few\ndifferent code samples that we've already worked with."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Begin with your working copy of the DPS310 sample."),(0,r.kt)("li",{parentName:"ol"},"Reference the ",(0,r.kt)("inlineCode",{parentName:"li"},"stream")," ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/golioth/magtag-demo/tree/stream"},"branch of the\nmagtag-demo")," repository:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"* Add in the Kconfig directives necessary to use Golioth by copying\n  everything from `prj.conf` and `esp32s2_saola.conf` from that branch into\n  those files in your DPS310 sample\n* Study how `main.c` writes accelerometer data to a LightDB stream endpoint\n  using the `golioth_lightdb_set()` function. Adapt this approach for your\n  DPS310 sensor readings.\n"))),(0,r.kt)("li",{parentName:"ol"},"Build, flash, and run the sample. Verify in ",(0,r.kt)("a",{parentName:"li",href:"https://console.golioth.io/"},"the Golioth\nConsole")," that your sensor data is being received by\nLightDB Stream")))}c.isMDXComponent=!0},3615:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/magtag-dps310-sensor-0eb0c0a725994d7b8a615fd4c8bf640a.jpg"},3657:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/magtag-i2c-pinout-17733e7910f83a2121517356bbb5ed79.png"}}]);