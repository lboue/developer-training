"use strict";(self.webpackChunkgolioth_developer_training=self.webpackChunkgolioth_developer_training||[]).push([[550],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,f=u["".concat(l,".").concat(h)]||u[h]||d[h]||a;return n?i.createElement(f,s(s({ref:t},c),{},{components:n})):i.createElement(f,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<a;p++)s[p]=n[p];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6752:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const a={sidebar_position:2,description:"Using Devicetree to map pins for input or output"},s="Zephyr Devicetree",o={unversionedId:"basic-io-exercises/devicetree",id:"basic-io-exercises/devicetree",title:"Zephyr Devicetree",description:"Using Devicetree to map pins for input or output",source:"@site/docs/basic-io-exercises/devicetree.md",sourceDirName:"basic-io-exercises",slug:"/basic-io-exercises/devicetree",permalink:"/docs/basic-io-exercises/devicetree",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,description:"Using Devicetree to map pins for input or output"},sidebar:"tutorialSidebar",previous:{title:"Basic I/O Exercises",permalink:"/docs/category/basic-io-exercises"},next:{title:"Blinking an LED",permalink:"/docs/basic-io-exercises/mapping-gpio"}},l={},p=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Desired outcome(s)",id:"desired-outcomes",level:3},{value:"Time Estimate",id:"time-estimate",level:3},{value:"Background Information",id:"background-information",level:2},{value:"DTS Files",id:"dts-files",level:3},{value:"Changing pin assignments with and overlay file",id:"changing-pin-assignments-with-and-overlay-file",level:3},{value:"The pinctrl subsystem",id:"the-pinctrl-subsystem",level:3},{value:"Devicetree files at build time",id:"devicetree-files-at-build-time",level:3},{value:"Some Devicetree resources to keep in mind",id:"some-devicetree-resources-to-keep-in-mind",level:3}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"zephyr-devicetree"},"Zephyr Devicetree"),(0,r.kt)("p",null,"Zephyr uses Devicetree bindings to associate pins, peripherals, and external\nhardware with an abstract definition in your code."),(0,r.kt)("p",null,"It won't take long for you to appreciate the power of this approach. If for some reason you need to change which pins are being used for a project, or you need to update the type of sensor you are using, it can be as easy as changing a few lines in your Devicetree overlay file, and leaving your C code completely untouched."),(0,r.kt)("h2",{id:"learning-objectives"},"Learning Objectives"),(0,r.kt)("p",null,"Understanding DeviceTree will allow you to work with a wider range of development boards than just the MagTag. It will also allow you to create custom hardware and interface to the peripherals on that hardware. "),(0,r.kt)("h3",{id:"desired-outcomes"},"Desired outcome(s)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Understand the formatting of DeviceTree"),(0,r.kt)("li",{parentName:"ul"},'Understand inheritance of "overlay files" and how they impact the DeviceTree')),(0,r.kt)("h3",{id:"time-estimate"},"Time Estimate"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"5 minutes")),(0,r.kt)("h2",{id:"background-information"},"Background Information"),(0,r.kt)("h3",{id:"dts-files"},"DTS Files"),(0,r.kt)("p",null,"All devices that are supported in Zephyr have a Devicetree source (DTS) included\nin the codebase. These files provide all of the hardware details Zephyr needs to\ninteract with them","\u2013","memory layout, clock speed, register addresses for\nperipherals for everything from GPIO to i2c, and more. These files are great for\nyou to reference, but you will not edit them directly unless you are adding your\nown board/chip that lacks official support. Do you need to know the clock speed\nand TX/RX pins used by the Espressif Saola dev board? Look in the DTS file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="excerpt from: ~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola.dts"',title:'"excerpt',"from:":!0,'~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola.dts"':!0},'&cpu0 {\n    clock-frequency = <ESP32_CLK_CPU_240M>;\n};\n\n&uart0 {\n    status = "okay";\n    current-speed = <115200>;\n    pinctrl-0 = <&uart0_default>;\n    pinctrl-names = "default";\n};\n')),(0,r.kt)("p",null,"From this we see that ",(0,r.kt)("inlineCode",{parentName:"p"},"uart0")," is using Pin Control (pinctrl) to define the pins with a\nstructure named ",(0,r.kt)("inlineCode",{parentName:"p"},"uart0_default"),". If we look in the ",(0,r.kt)("inlineCode",{parentName:"p"},"<board>-pinctrl.dtsi")," file\nwe can see exactly which pins are assigned in that structure, and that one of\nthose pins is configured with a pull-up resistor enabled."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="excerpt from ~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola-pinctrl.dtsi"',title:'"excerpt',from:!0,'~/Desktop/magtag-training/deps/zephyr/boards/xtensa/esp32s2_saola/esp32s2_saola-pinctrl.dtsi"':!0},"&pinctrl {\n    uart0_default: uart0_default {\n        group1 {\n            pinmux = <UART0_TX_GPIO43>;\n        };\n        group2 {\n            pinmux = <UART0_RX_GPIO44>;\n            bias-pull-up;\n        };\n    };\n};\n")),(0,r.kt)("h3",{id:"changing-pin-assignments-with-and-overlay-file"},"Changing pin assignments with and overlay file"),(0,r.kt)("p",null,"Each project can specify one or more Devicetree overlay files. This is where\nyour application code will declare its intention to use pins and peripherals.\nFor instance, the MagTag sample code turns on an i2c bus and selects the pins\nfor the SDA and SCL lines signals that are connected to the accelerometer.\nOverlay files are located in a ",(0,r.kt)("inlineCode",{parentName:"p"},"boards/")," subdirectory of your application code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="MagTag accelerometer excerpt from: ~/magtag-training/app/boards/esp32s2_saola.overlay"',title:'"MagTag',accelerometer:!0,excerpt:!0,"from:":!0,'~/magtag-training/app/boards/esp32s2_saola.overlay"':!0},'&i2c1 {\n    pinctrl-0 = <&i2c1_default>;\n    status = "okay";\n\n    lis3dh@19 {\n            compatible = "st,lis2dh";\n            reg = <0x19>;\n    };\n};\n\n&pinctrl {\n    i2c1_default: i2c1_default {\n        group1 {\n            pinmux = <I2C1_SDA_GPIO33>,\n                     <I2C1_SCL_GPIO34>;\n        };\n    };\n};\n')),(0,r.kt)("h3",{id:"the-pinctrl-subsystem"},"The pinctrl subsystem"),(0,r.kt)("p",null,"Special function pins like the SDA/SCL lines are specified using the pinctrl\nsubsystem of Zephyr. The syntax for these pins varies from one chip manufacturer\nto the next, so it is good to peruse the documentation. By consulting ",(0,r.kt)("a",{parentName:"p",href:"https://docs.zephyrproject.org/latest/build/dts/api/bindings.html"},"the\nZephyr bindings\nindex"),", we\nfind ",(0,r.kt)("a",{parentName:"p",href:"https://docs.zephyrproject.org/latest/build/dts/api/bindings/pinctrl/espressif%2Cesp32-pinctrl.html"},"useful documentation on the Espressif pinctrl\npage"),"."),(0,r.kt)("p",null,"Espressif has approached pinctrl by making a definition for every possible\nconfiguration of every pin. These definitions are found in the include folder of\nthe Espressif hardware abstraction layer module. For the MagTag demo, the i2c1\npins needed remapping. Here is an excerpt of the relevant define for the SDA\npin. Compare this to what is found in the overlay file above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Espressif esp32s2 pinctrl definitions: ~/Desktop/magtag-training/deps/modules/hal/espressif/include/dt-bindings/pinctrl/esp32s2-pinctrl.h"',title:'"Espressif',esp32s2:!0,pinctrl:!0,"definitions:":!0,'~/Desktop/magtag-training/deps/modules/hal/espressif/include/dt-bindings/pinctrl/esp32s2-pinctrl.h"':!0},"#define I2C1_SDA_GPIO31 \\\n    ESP32_PINMUX(31, ESP_I2CEXT1_SDA_IN, ESP_I2CEXT1_SDA_OUT)\n\n#define I2C1_SDA_GPIO32 \\\n    ESP32_PINMUX(32, ESP_I2CEXT1_SDA_IN, ESP_I2CEXT1_SDA_OUT)\n\n#define I2C1_SDA_GPIO33 \\\n    ESP32_PINMUX(33, ESP_I2CEXT1_SDA_IN, ESP_I2CEXT1_SDA_OUT)\n\n#define I2C1_SDA_GPIO34 \\\n    ESP32_PINMUX(34, ESP_I2CEXT1_SDA_IN, ESP_I2CEXT1_SDA_OUT)\n\n")),(0,r.kt)("p",null,"The defines from the esp32s2-pinctrl.h file are used to populate subnodes inside\nthe pinctrl node of our overlay file. (The anatomy of a Devicetree node will be\ndiscussed in the next exercise: ",(0,r.kt)("a",{parentName:"p",href:"/docs/basic-io-exercises/mapping-gpio"},"Blinking an LED"),".)"),(0,r.kt)("p",null,"It's normal to feel confused over the details at this point. Devicetree is a\ncomplex topic that will take time to fully understand. We recommend looking at\noverlay files from sample code, and review ",(0,r.kt)("a",{parentName:"p",href:"https://blog.golioth.io/how-to-use-zephyr-pin-control-pinctrl-for-pin-multiplexing-and-configuration/"},"the pinctrl post on the Golioth\nblog"),"\nto help build your early understanding."),(0,r.kt)("h3",{id:"devicetree-files-at-build-time"},"Devicetree files at build time"),(0,r.kt)("p",null,"All Devicetree files are merged together at build time. Anything your overlay\nfiles change will be incorporated with inherited settings from the board and/or\nchip DTS files. Notice that a lot of properties from the chip's ",(0,r.kt)("inlineCode",{parentName:"p"},"esp32s2.dtsi"),"\nfile have joined the i2c settings we saw in the overlay file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="Excerpts from ~/Desktop/magtag-training/app/build/zephyr/zepyr.dts whosing i2c1 pins and configuration"',title:'"Excerpts',from:!0,"~/Desktop/magtag-training/app/build/zephyr/zepyr.dts":!0,whosing:!0,i2c1:!0,pins:!0,and:!0,'configuration"':!0},'/ {\n    #address-cells = < 0x1 >;\n    #size-cells = < 0x1 >;\n    model = "esp32s2_saola";\n    compatible = "espressif,esp32s2";\n\n    soc {\n        #address-cells = < 0x1 >;\n        #size-cells = < 0x1 >;\n        compatible = "simple-bus";\n        ranges;\n\n        i2c1: i2c@3f427000 {\n            compatible = "espressif,esp32-i2c";\n            #address-cells = < 0x1 >;\n            #size-cells = < 0x0 >;\n            reg = < 0x3f427000 0x1000 >;\n            interrupts = < 0x35 >;\n            interrupt-parent = < &intc >;\n            clocks = < &rtc 0x5 >;\n            status = "okay";\n            clock-frequency = < 0x186a0 >;\n            pinctrl-0 = < &i2c1_default >;\n            pinctrl-names = "default";\n            lis3dh@19 {\n                compatible = "st,lis2dh";\n                reg = < 0x19 >;\n            };\n        };\n  };\n\n    pinctrl: pin-controller {\n        compatible = "espressif,esp32-pinctrl";\n        status = "okay";\n        i2c1_default: i2c1_default {\n            phandle = < 0x5 >;\n            group1 {\n                pinmux = < 0x301821 >, < 0x2f97e2 >;\n                bias-pull-up;\n                drive-open-drain;\n                output-high;\n            };\n        };\n    };\n};\n')),(0,r.kt)("p",null,"Note that the pinmux instruction in the pinctrl node is no longer\nhuman-readable, but we do see the pin configuration commands which were pulled\nin from the board's pinctrl.dtsi file in Zephyr. All our overlay file did was\nchange which pins are used for those signals."),(0,r.kt)("p",null,"Now if you were to use a different variant of the chip (say the ESP32 instead of\nthe ESP32s2), you add your overlay file for that variant and the Devicetree will\npull in the correct register address and other settings for the new part without\nanything more than changing the board name in the build command."),(0,r.kt)("h3",{id:"some-devicetree-resources-to-keep-in-mind"},"Some Devicetree resources to keep in mind"),(0,r.kt)("p",null,"Today's training will guide you through your first small steps in using\nDevicetree. As you advance, consider reading through ",(0,r.kt)("a",{parentName:"p",href:"https://docs.zephyrproject.org/latest/build/dts/intro.html"},"the Zephyr Devicetree\ndocs"),". We also\nrecommend watching this talk from Marti Bolivar at the 2021 Zephyr Developer's\nSummit that ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=sWaxQyIgEBY"},"walks through the core Devicetree\nconcepts"),"."))}d.isMDXComponent=!0}}]);